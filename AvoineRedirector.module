<?php

/*
 *
 * TODO:
 *
 *   - Remove caching stuff and always write the serialized data to the module's config
 *     (not sure if it's a bit dirty though, since PW stores the data as JSON)
 *
 */
class AvoineRedirector extends WireData implements Module, ConfigurableModule {
  protected $cacheKeyName = 'AvoineRedirector.routes';
  protected $cacheTtl = 3600;

  /*
   *
   *
   * Module info
   *
   *
   */
	public static function getModuleInfo() {
		return [
			'title' => 'Avoine Redirector',
			'version' => '1.0.0',
			'summary' => 'A static host based redirect router.',
			'singular' => true,
			'autoload' => true,
    ];
	}

  /*
   *
   *
   * Hooks
   *
   *
   */
	public function init() {
    // Redirecting will be done here
    $this->addHookBefore('ProcessPageView::execute', $this, 'router');
    // Auto update cache on module config save will be done here
    $this->addHookAfter('Modules::saveModuleConfigData', $this, 'updateRoutesCache');
	}
  
  /*
   *
   *
   * Main routing logic (hook)
   *
   *
   */
  public function router(HookEvent $event) {
    // Read routes from cache while automatically caching when it's expired
    $routes = $this->cacheGet($this->cacheKeyName, $this->cacheTtl, function() {
      return $this->getParsedRoutes($this->routes);
    });

    // Fast exist for misconfigured module
    if(count($routes) === 0) {
      return;
    }
    
    // Use strtolower to avoid case problems
    $host = strtolower($this->config->httpHost);
    
    // Quick exist if the request is made against the main host
    if($routes[0] === $host) {
      return;
    }

    // Match HTTP host
    if(isset($routes[$host])) {
      list($url, $append) = $routes[$host];
      if($append) {
        // Append the path to the target_path
        $url.= ltrim($_SERVER['REQUEST_URI'], '/');
      }
      $this->session->redirect($url);  
    }
  }
  
  /*
   *
   *
   * Hook to execute on module config save
   *
   *
   */
  public function updateRoutesCache(HookEvent $e) {
    // Updates cache based on the event arguments
    $this->cacheSave($this->cacheKeyName, $this->getParsedRoutes($e->arguments(1)['routes']), $this->cacheTtl);
  }
  
  /*
   *
   *
   * Helper for parsing the configuration string into routes array
   *
   *
   */
  public function getParsedRoutes($routesString) {
    $httpHosts = $this->config->httpHosts;
    if(!is_array($httpHosts) or count($httpHosts) === 0) {
      // httpHosts hasn't been configured, exit early
      return [];
    }
    
    // The first item in httpHosts will be automatically used as the main host (i.e. where redirects are sent)
    $mainHost = strtolower($httpHosts[0]);
    
    // Remove dirty windows characters
    $routesString = trim(str_replace("\r", '', $routesString));
    if(strlen($routesString) === 0) {
      // Unconfigured module, exit early
      return [];
    }

    // We add the mainhost as the first item so it can be used for early exit in the router
    $routes = [$mainHost];
    
    // Split lines
    $routesTemp = explode("\n", $routesString);

    foreach($routesTemp as $routeLine) {
      $routeLine = trim($routeLine);

      if(strlen($routeLine) === 0) {
        // Skip empty lines
        continue;
      }
      
      // Fields are separated with spaces
      $routeParts = explode(' ', $routeLine);
      if(count($routeParts) < 2) {
        // Discard incomplete routes silently
        continue;
      }
      
      if($routeParts[1]{0} !== '/') {
        // Discard paths not starting with a forward slash
        continue;
      }
      
      if(strpos($routeParts[0], '/') !== false) {
        // Discard request_hosts that contain a path
        continue;
      }
      
      if(substr($routeParts[1], -1) !== '/') {
        // Always append a trailing forward slash to the target path
        $routeParts[1].= '/';
      }
      
      // Finally construct the URL
      $targetUrl = '//' . $mainHost . '/' . ltrim($this->config->urls->root . $routeParts[1], '/');
      $appendFlag = !empty($routeParts[2]);
      
      // Use strtolower to avoid case problems
      $routes[strtolower($routeParts[0])] = [$targetUrl, $appendFlag];
    }
    
    return $routes;
  }
  
  /*
   *
   *
   * Caching related methods start here, which were added due $cache API missing in PW 2.4
   *
   *
   */
  
  protected function getCachePath($key) {
    // Cached items are stored under /tmp
    return $fullpath = sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'AvoineCache.' . $key;
  }
  
  protected function cacheGet($key, $ttl = false, $function = false) {
    // Validate arguments
    if($function !== false and !is_callable($function)) {
      throw new WireException('$function must be callable');
    } elseif($ttl !== false and !is_int($ttl)) {
      throw new WireException('$ttl must be an int');
    }
    
    $fullpath = $this->getCachePath($key);
    
    // Check if we have something cached
    if(!file_exists($fullpath)) {
      // Cache file does not exist, so check if the user supplied a generator function
      if($function !== false) {
        // Generator was given so update cache and return data
        $data = $function();
        $this->cacheSave($key, $data, $ttl);
        return $data;
      } else {
        // Otherwise we let the user know there's nothing in the cache
        return null;
      }
    } else {
      // Get raw contents from the cache file
      $contents = file_get_contents($fullpath);
      
      if($contents === false) {
        throw new WireException('Unable to get cache contents');
      }
      
      $cacheItem = unserialize($contents);
      
      // Validate the unserialized array
      if(!is_array($cacheItem) or !isset($cacheItem['ttl']) or !isset($cacheItem['timestamp'])) {
        // Corrupted cache, removing
        if(!unlink($fullpath)) {
          throw new WireException('Unable to remove cache');
        }
        // Attempt again
        return $this->cacheGet($key, $ttl, $function);
      }
      
      if(time() - $cacheItem['timestamp'] > $cacheItem['ttl']) {
        // Cache has expired
        if(!unlink($fullpath)) {
          throw new WireException('Unable to remove cache');
        }
        // Attempt again
        return $this->cacheGet($key, $ttl, $function);
      } else {
        // Yay, cached data was found.
        return $cacheItem['data'];
      }
    }
  }
  
  protected function cacheSave($key, $data, $ttl = false) {
    if($ttl === false) {
      // Default to one hour
      $ttl = 3600;
    } elseif(!is_int($ttl)) {
      throw new WireException('$ttl must be an int');
    }
    
    $cachedItem = [
      'ttl'       => $ttl,
      'timestamp' => time(),
      'data'      => $data,
    ];
    
    if(file_put_contents($this->getCachePath($key), serialize($cachedItem)) === false) {
      throw new WireException('Unable to save cache');
    }
  }
  
  /*
   *
   *
   * Module config fields
   *
   *
   */
	static public function getModuleConfigInputfields(array $data) {

		$fields = new InputfieldWrapper();

		$field = wire('modules')->get("InputfieldTextarea");
		$field->name = "routes";
		$field->label = "Redirect routes";
		$field->description = "Add each redirect route on it's own line. Use syntax <request_host> <target_path> [<append>]";
		$field->notes = "IMPORTANT: httpHosts must be defined in the config. Start all paths with '/'. Do not include a path in request_host. If you wish to append the request path, place an 'x' as the last field. Even if PW is running under a directory other than the root, do not include it, it will be added as necessary. Trailing forward slash will be added automatically to all target_paths.";
		$field->attr('value', $data['routes']);
		$fields->add($field);

		return $fields;
	}
}